@page "/"
@using ZipTabel.Components
@inject IJSRuntime JSRuntime
<PageTitle>Home</PageTitle>
<script src="js/script.js"></script>

<table border="1">
    <thead>
        <tr>
            <th></th>
            @for (int col = 1; col <= TotalCols; col++)
            {
                <th>@GetColumnLetter(col)</th>
            }
        </tr>
    </thead>
    <tbody>
        @for (int row = 1; row <= TotalRows; row++)
        {
            <tr>
                <td>@row</td>
                @for (int col = 1; col <= TotalCols; col++)
                {
                    var address = GetCellAddress(row, col);
                    var cell = Sheet.GetCell(address);
                    <td @onclick="() => OnCellClick(cell)"
                    @onmousedown="() => OnMouseDown(cell)"
                    @onmouseup="() => OnMouseUp(cell)"
                    @onmousemove="() => OnMouseMove(cell)"
                    style="background-color: @(SelectedCells.Contains(cell) ? "red" : "white")">
                        <ZipTabel.Components.CellView Cell="@cell" />
                    </td>
                }
            </tr>
        }
    </tbody>

</table>

<script>
    let blazorComponent;
    //проверка y
    window.scrollToBottomHandler = () => {
    const scrollTop = window.scrollY || document.documentElement.scrollTop;
    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight - 20;

    if (scrollTop + windowHeight >= documentHeight) {
    blazorComponent.invokeMethodAsync('YourBlazorMethodForVerticalScroll');
    }
    };
    //проверка x
    window.scrollToRightHandler = () => {
    const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
    const windowWidth = window.innerWidth;
    const documentWidth = document.documentElement.scrollWidth - 20;

    if (scrollLeft + windowWidth >= documentWidth) {
    blazorComponent.invokeMethodAsync('YourBlazorMethodForHorizontalScroll');
    }
    };
    //вызов
    window.initializeScrollListeners = (dotNetReference) => {
    blazorComponent = dotNetReference;
    window.addEventListener('scroll', scrollToBottomHandler);
    window.addEventListener('scroll', scrollToRightHandler);
    };

    window.removeScrollListeners = () => {
    window.removeEventListener('scroll', scrollToBottomHandler);
    window.removeEventListener('scroll', scrollToRightHandler);
    };
</script>


@code {
    private List<Cell> SelectedCells = new(); // Список выделенных ячеек
    private Cell StartCell; // Начальная ячейка выделения
    private bool IsSelecting = false; // Флаг выбора
    public Sheet Sheet = new Sheet("Лист1");
    private int TotalRows = 30;
    private int TotalCols = 30;
    private int maxWidth;

    protected override async Task OnInitializedAsync()
    {
        await InitializeSheetAsync();
    }

    [JSInvokable("YourBlazorMethodForVerticalScroll")]
    public void YourBlazorMethodForVerticalScroll()
    {
        TotalRows++;
        var address = GetCellAddress(TotalRows, 1);
        Sheet.AddCell(address, new Cell(address));

        // Console.WriteLine("y");

        StateHasChanged();
    }

    [JSInvokable("YourBlazorMethodForHorizontalScroll")]
    public void YourBlazorMethodForHorizontalScroll()
    {
        TotalCols++;
        var address = GetCellAddress(1, TotalCols);
        Sheet.AddCell(address, new Cell(address));

        // Console.WriteLine("x");

        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Передаем ссылку на экземпляр компонента
            await JSRuntime.InvokeVoidAsync("initializeScrollListeners", DotNetObjectReference.Create(this));
        }
    }

    public void Dispose()
    {
        JSRuntime.InvokeVoidAsync("removeScrollListeners");
    }

    private async Task InitializeSheetAsync()
    {
        // for (int row = 1; row <= TotalRows; row++)
        // {
        //     for (int col = 1; col <= TotalCols; col++)
        //     {
        //         var address = GetCellAddress(row, col);
        //         Sheet.AddCell(address, new Cell(address));
        //     }
        // }
    }



    private string GetCellAddress(int row, int col)
    {
        return $"{GetColumnLetter(col)}{row}";
    }

    private string GetColumnLetter(int col)
    {
        int dividend = col;
        string columnLetter = string.Empty;
        while (dividend > 0)
        {
            int modulo = (dividend - 1) % 26;
            columnLetter = Convert.ToChar(65 + modulo) + columnLetter;
            dividend = (dividend - modulo) / 26;
        }
        return columnLetter;
    }

    private async Task OnCellClick(Cell cell)
    {
        // await JSRuntime.InvokeVoidAsync("window.logToConsole", $"OnCellClick{cell.Address}");
    }
    private async Task OnMouseDown(Cell cell)
    {
        StartCell = cell;
        IsSelecting = true; 
        SelectedCells.Clear(); 
        SelectedCells.Add(cell); 
    }

    private async Task OnMouseMove(Cell cell)
    {

        if (IsSelecting)
        {
            await UpdateSelectedCells(StartCell, cell);
        }
    }

    private async Task OnMouseUp(Cell cell)
    {
        
        IsSelecting = false; // Завершаем процесс выделения
        await UpdateSelectedCells(StartCell, cell); // Обновляем финальный диапазон
                                              // await JSRuntime.InvokeVoidAsync("window.logToConsole", $"OnMouseUp: {cell.Address}");
    }

    // Метод для вычисления диапазона выделения
    private async Task UpdateSelectedCells(Cell startCell, Cell endCell)
    {
        if (startCell.Address == endCell.Address)
        {
            SelectedCells.Clear();
            return;
        }
        SelectedCells.Clear();

        var (startRow, startCol) = ParseCellAddress(startCell.Address);
        var (endRow, endCol) = ParseCellAddress(endCell.Address);

        int minRow = Math.Min(startRow, endRow);
        int maxRow = Math.Max(startRow, endRow);
        int minCol = Math.Min(startCol, endCol);
        int maxCol = Math.Max(startCol, endCol);

        // Добавляем ячейки в выделенный диапазон
        for (int row = minRow; row <= maxRow; row++)
        {
            for (int col = minCol; col <= maxCol; col++)
            {
                var address = GetCellAddress(row, col);
                var cell = Sheet.GetCell(address);
                SelectedCells.Add(cell);
            }
        }

        await InvokeAsync(StateHasChanged); // Обновляем UI
    }

    private (int row, int col) ParseCellAddress(string address)
    {
        int col = 0;
        int row = 0;

        foreach (char c in address)
        {
            if (char.IsLetter(c))
            {
                col = col * 26 + (char.ToUpper(c) - 'A' + 1);
            }
            else if (char.IsDigit(c))
            {
                row = row * 10 + (c - '0');
            }
        }

        return (row, col);
    }
}
